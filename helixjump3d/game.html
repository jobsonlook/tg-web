<html>
<head>
  <title>helix Jump 3D</title>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <link href="style.css" rel="stylesheet" type="text/css">

  <!-- Yo -->
  <script src="js/jquery.js"></script>
  <script src="js/three.js"></script>
  <script src="js/loaders/GLTFLoader.js"></script>

  <script src="js/KeyboardState.js"></script>

  <!-- GD Ads -->
  <!-- <script type="text/javascript" src="js/h5-ad-wrapper/dist/ad-wrapper.umd.js"></script> -->

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','','ga');
 
  </script>

</head>
<body onload="Init();" onresize="onResize();">
  <div id="menu" class="GUIPage">

      <div id="menu_content">
        <img id="logo_menu" src="img/logo.png"/>
        <br/><br/>

        <a class="defaultButton" onclick="StartGameFromMenu();" style="margin-bottom: 18px;" id="buttonPlay">START</a>
        <br/>

        <a style="display: none; padding-bottom: 20px !important;" id="buttonContinueLastLevel" class="defaultButton" onclick="StartGameFromLastLevel();" id="buttonPlay">
          CONTINUE
          <h4 style="position: absolute; bottom: -18px; left: 100px;" id="textLastLevel">Level 99</h4>
        </a>

        <a style="display: block;" class="buttonMoreGames" 
          >
          <br/>
          <img src="img/more-games.png" />
        </a>

      </div>
  </div>

  <div id="ingame" class="GUIPage">
    <h2 style="margin: 0px; padding: 10px; " id="textScore">999</h2>

    <h4 style="position: fixed; top: 0px; right: 12px;" >LEVEL</h4>
    <h2 style="position: fixed; top: 10px; right: 12px;" class="textBig" id="textLevel" >99</h2>
  </div>

  <div id="levelcompleted" class="GUIPage">
    <h2 id="textLevelComplete">LEVEL XXX COMPLETE</h2>
  </div>

  <div id="gameover" class="GUIPage pageBlack">
    <div style="position: fixed; bottom: 35%; width: 100%;">
      <h1>GAME OVER</h1>
      <br/><br/>
      <a onclick="RestartGame();" class="defaultButton" >TRY AGAIN</a>
      
    

      <br>
      <a style="display: block;" class="buttonMoreGames" 
          >
          <br/>
          <img src="img/more-games.png" />
        </a>
    </div>
  </div>

  <div id="divSound">
    <a id="buttonMusic" onclick="ToggleMusic();" style="position: fixed; top: 24px; right: 92px;">
      <img src="img/icon-music.png"/>
    </a>

    <a id="buttonSound" onclick="ToggleSound();" style="position: fixed; top: 24px; right: 24px;">
      <img src="img/icon-sound.png"/>
    </a>
  </div>

  <h4 style="position: fixed; top: 0px; left: 12px;" >BEST SCORE</h4>
  <h2 style="position: fixed; top: 10px; left: 12px;" id="textBestScore">0</h2>

  <div id="scoreHUB_1" class="scoreHUB">+1</div>
  <div id="scoreHUB_2" class="scoreHUB">+1</div>
  <div id="scoreHUB_3" class="scoreHUB">+1</div>

  <div id="orientation" class="fullPage" style="display: none;" ></div>

  <div id="splash" class="fullPage" style="height: 100%;" >
    <img style="display: none;" id="logoHuz" src="img/logo-huz.png"/>
  </div>

  <script>

      //Splash
      $('#logoHuz').fadeIn(2500);
      setTimeout(function() {
         $('#splash').fadeOut(2000);
         $('#logoHuz').fadeOut(2000);
       }, 2500);
       //$('#splash').hide();

      //Init UI
      $('.GUIPage').hide();

      //Orientation
      window.addEventListener('orientationchange', function () {
        OnOrientationChange();
      });

      function IsMobile() { 
       if( navigator.userAgent.match(/Android/i)
       || navigator.userAgent.match(/webOS/i)
       || navigator.userAgent.match(/iPhone/i)
       || navigator.userAgent.match(/iPad/i)
       || navigator.userAgent.match(/iPod/i)
       || navigator.userAgent.match(/BlackBerry/i)
       || navigator.userAgent.match(/Windows Phone/i)
       ){
          return true;
        }
       else {
          return false;
        }
      }

      function OnOrientationChange()
      {
        setTimeout(function(){
            if (IsMobile() == true)
            {
              if(window.innerHeight < window.innerWidth)
              {
                $('#orientation').show();
              }
              else
              {
                $('#orientation').hide();
              }
            }
          }, 100);
      }

      function onResize()
      {
        console.log("onWindowResize");
        setTimeout(function(){
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );

          var pageHeight = window.innerHeight;

          $('.GUIPage').css('min-height',pageHeight);
          $('.GUIPage').css('height',pageHeight);
          $('.GUIPage').css('max-height',pageHeight);

          $('.fullPage').css('min-height',pageHeight);
          $('.fullPage').css('height',pageHeight);
          $('.fullPage').css('max-height',pageHeight);
        }, 100);

        OnOrientationChange();
      }

      //Score HUB
      var currentScoreHub = 1;
      function ShowScoreHUB(scoreValue)
      {
        $("#scoreHUB_"+currentScoreHub).css("opacity", 1);
        $("#scoreHUB_"+currentScoreHub).css("top", "40%");

        $("#scoreHUB_"+currentScoreHub).html("+" + scoreValue);

        $("#scoreHUB_"+currentScoreHub).show();
        $("#scoreHUB_"+currentScoreHub).animate({
          top: "5%",
          opacity: 0
        }, 1000);
        currentScoreHub++;
        if(currentScoreHub>3)
          currentScoreHub = 1;
      }

      //UI
      function Init()
      {
        currentLevel = 1;

        onResize();

        GetLocalStorage();

        ShowUIScreen('menu');

     
        
        //Particles
        InitParticles();

        //Preload level 1
        GenerateLevel();

        gameState = 2;

        
          $('.buttonMoreGames').hide();
        
      }

      function ShowLevelCompleted()
      {
        $('#textLevelComplete').html('LEVEL <spam class="color2">' + currentLevel + "</spam><br/>COMPLETE");
        $('#levelcompleted').fadeIn('slow').delay(1500).fadeOut('slow');
      }

      function ShowUIScreen(divId)
      {
        $('.GUIPage').hide();
        $('#' + divId).fadeIn('slow');

        if(divId == "menu" || divId == "gameover")
        {
          $("#divSound").show();
        }
        else
        {
          $("#divSound").hide();
        }
      }

      function UpdateGameUI()
      {
        $('#textScore').html(score);
        $('#textLevel').html(currentLevel);
      }

      //GAME
      function GenerateLevel()
      {
        
        RandomizeWorldColors();
        
        //Game
        numPlatformsSpawned = 0;

        lastBlockPositionY = -5000;

        lastPosY = -0.1;
        nextPosYForRespawn = -0.5;

        ball.position.set(0,0.25,0.8);

        //Generate level
        GenerateLevelSettings();

        //Clear all
        while (arrayWalls.length)
          arrayWalls.pop();

        if(pivot != null)
        {
          scene.remove(pivot);
        }
        pivot = new THREE.Mesh( geometry, materialOk );
        scene.add(pivot);

        //Initial platforms
        for(var i=0; i<maxRings; i++)
          GeneratePlatform();
      }

      function StartGameFromLastLevel()
      {
        currentLevel = lastLevel;
        StartGame();

       
      }

      function StartGameFromMenu()
      {
        
        StartGame();
      }

      function StartGame()
      {
          if (!window.IS_FIRST) {
            window.IS_FIRST = true;
          }
          else {
            setLoadingVisible(true, true, function () {
              StartGame2();
            })
            return;
          }
          StartGame2();
        
      }

      function StartGame2()
      {

        //Show ad
        //ShowInterstitial();

        UpdateGameUI();

        ShowUIScreen('ingame');

        if(currentLevel != 1)
        {
          GenerateLevel();
        }
        
        ball.scale.set(1,1,1);

        cameraTargetY = 0;
        ballGravity = 0;
        platformsWithoutBounceCount = 0;

        //Play...
        canPlay = true;
        gameState = 1;

        PlaySound("level-start");
      }

      function CompleteLevel()
      {
        if(gameState == 3)
          return;

        //ball.scale.set(0,0,0);

        PlaySound("level-complete");
        //console.log("CompleteLevel");
        try {
					// parent.post_ad();
					console.log("CompleteLevel");
				} catch (error) {
					console.error("ad",error);
				}
        ShowLevelCompleted();

        gameState = 3;
        canPlay = false;
        cameraTargetY = 0;

        setTimeout(function() {
         LoadNextLevel();
       }, 1500);

        CheckForSaveBestScore();
      }

      function LoadNextLevel()
      {
        //Clear all
        if(pivot != null)
        {
          scene.remove(pivot);
        }

        currentLevel ++;

        //Save
        if(currentLevel > lastLevel)
        {
          lastLevel = currentLevel;
          localStorage.setItem(localStoragePrefix+"lastLevel", lastLevel);
        }

        StartGame();
      }

      function RestartGame()
      {
        //Show ad
        // ShowInterstitial();

        //Regenerate if is level 1...
        if(currentLevel == 1)
        {
          GenerateLevel();
        }

        //Init();
        score = 0;
        StartGame();
      }

      function ResumeGame()
      {
        //Make it nice again
        if(lastBlockBounced != null)
        {
          lastBlockBounced.userData.platformType = "normal";
          lastBlockBounced.children[0].traverse ( ( o ) => { o.material = materialOk; } );
        }
        //Is a wall?
        if(lastWallBounced != null)
        {
          var index = arrayWalls.indexOf(lastWallBounced);
          if (index > -1) {
            arrayWalls.splice(index, 1);
          }

          scene.add(lastWallBounced);
          scene.remove(lastWallBounced);
        }

        UpdateGameUI();
        ShowUIScreen('ingame');
        //Game
        canPlay = true;
        gameState = 1;
      }

      function GameOver()
      {
        if(gameState == 2)
          return;

      

        gameState = 2;

        canPlay = false;

        ShowUIScreen('gameover');

        CheckForSaveBestScore();
      }

      function CheckForSaveBestScore()
      {
        //Save best score
        if(score > bestScore)
        {
          bestScore = score;
          $('#textBestScore').html(bestScore);
          localStorage.setItem(localStoragePrefix+"bestScore", score);
        }
      }

      

      //Storage
      var localStorage = window.localStorage;
      var localStoragePrefix = "HyperHelix_";

      function GetLocalStorage()
      {
        bestScore = 0;
        var bestScoreValue = localStorage.getItem(localStoragePrefix+"bestScore");
        if(bestScoreValue != null)
        {
          bestScore = bestScoreValue;
          $('#textBestScore').html(bestScore);
        }

        //Last level
        var lastLevelValue = localStorage.getItem(localStoragePrefix+"lastLevel");
        if(lastLevelValue != null && lastLevelValue != "")
        {
          lastLevel = lastLevelValue;
          $('#textLastLevel').html("Level " + lastLevel);
          $('#buttonContinueLastLevel').show();
        }

        //Music and sound
        var musicMuteValue = localStorage.getItem(localStoragePrefix+"musicMute");
        if(musicMuteValue != null && musicMuteValue == "true")
        {
          musicMute = true;
        }

        var soundMuteValue = localStorage.getItem(localStoragePrefix+"soundMute");
        if(soundMuteValue != null && soundMuteValue == "true")
        {
          soundMute = true;
        }

        CheckMusicSoundMute();
      }

      //Game parameters
      var gameState = 0;
      //0-menu
      //1-ingame
      //2-gameover
      //3-level completed

      var currentLevel = 1;
      var lastLevel = 1;

      var numPlatformsSpawned = 0;
      var piecesOnLevel = 2;
      var chanceForDeadPiece = 20;

      var lastBlockBounced;
      var lastWallBounced;

      var ballGravity = 0;
      var score = 0;
      var bestScore = 0;

      var lastBlockPositionY = -5000;

      var canPlay = false;

      var maxRings = 5;

      var clock = new THREE.Clock();
      clock.start();

      //        Colors
      //0-ok
      //1-ko/ball
      var worldColorIn = 1;
      var worldColors = [];
      worldColors[0] = [0xcf455c,0x470031];//pink
      worldColors[1] = [0x777777,0xc12a08];//white-orange
      worldColors[2] = [0x847c2d,0x7a2c0b];//yellow-red
      worldColors[3] = [0x354314,0x988012];//green-yellow
      worldColors[4] = [0x121111,0x890a25];//black-pink
      worldColors[5] = [0x121111,0x988012];//black-yellow

      //console.log(worldColors);
      //console.log(worldColors[0][0]);

      //Scene
      var scene = new THREE.Scene();

      var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize( window.innerWidth, window.innerHeight );
      //renderer.setClearColor (worldColors[worldColorIn][3], 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

      document.body.appendChild( renderer.domElement );

      //Lights
      var shadowLight = new THREE.PointLight( 0xffffff, 1, 100 );
      shadowLight.position.set( 0, -3, 3);
      shadowLight.castShadow = true;            // default false
      scene.add( shadowLight );

      //Set up shadow properties for the light
      shadowLight.shadow.mapSize.width = 512;  // default
      shadowLight.shadow.mapSize.height = 512; // default
      shadowLight.shadow.camera.near = 0.1;       // default
      shadowLight.shadow.camera.far = 10;      // default

      var directionalLight = new THREE.DirectionalLight( 0xdddddd, 1.8 );
      directionalLight.position.set( -40, 80, 80 );
      scene.add(directionalLight);

      var ambientLight = new THREE.AmbientLight( 0xe7e7e7 ); // soft white light
      scene.add( ambientLight );

      //Materials
      var materialBall = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][1] } );
      var materialCore = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0] } );
      var materialSpecial = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0] } );
      var materialOk = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0] } );
      var materialKo = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][1] } );
      var materialFinish = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0] } );
      var splatMaterial = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'img/splat-1.png' ), transparent: true, opacity: 1, color: worldColors[worldColorIn][1] });

      //Camera
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
      camera.position.y = 1;
      camera.position.z = 5;
      camera.rotation.x = (-22 * Math.PI)/180;//initial rotation
      var cameraTargetY = 0;

      //3D Models
      var loader = new THREE.GLTFLoader();

      var blockMesh;
      var blocksCore;
      var wallMesh;

      var keyboard = new THREEx.KeyboardState();

      //var rings = [];
      var lastPosY = 0;

      var nextPosYForRespawn = -0.5;

      var platformsWithoutBounceCount = 0;

      var ringIn = new THREE.Group();
      //groups.push(ringIn);

      //Ball
      var ballPivot = new THREE.Group();
      scene.add(ballPivot);
      ballPivot.position.set(0,2,0);

      var geometryBall = new THREE.SphereGeometry( 0.1, 32, 32 );
      var ball = new THREE.Mesh( geometryBall, materialBall );
      ballPivot.add(ball);
      ball.position.set(0,0,0.8);
      ball.name = "Ball";
      ball.castShadow = true; //default is false
      scene.add( ball );

      // SUPER SIMPLE GLOW EFFECT
      // use sprite because it appears the same from all angles
      var spriteMaterial = new THREE.SpriteMaterial( 
      { 
        map: new THREE.ImageUtils.loadTexture( 'img/circle-gradient.png' ), 
        useScreenCoordinates: false,
        color: 0x0000ff, transparent: true, blending: THREE.AdditiveBlending
      });
      var ballGlow = new THREE.Sprite( spriteMaterial );
      ballGlow.scale.set(1, 1, 1.0);
      ball.add(ballGlow); // this centers the glow at the mesh


      //attach shadow point light...
      //ball.add(shadowLight);
      shadowLight.position.set( 0, 3, 1);

      //ballPivot.add(camera);

      //Map
      var geometry = new THREE.BoxGeometry( 0.01,0.01,0.01 );

      var pivot = new THREE.Object3D();
      scene.add( pivot );

      //Load 3D assets
      loader.load( 'models/circle-piece.glb', function ( gltf ) {
        blockMesh = gltf.scene;
      }, undefined, function ( error ) {
        console.error( error );
      });

      loader.load( 'models/wall.glb', function ( gltf ) {
        wallMesh = gltf.scene;
      }, undefined, function ( error ) {
        console.error( error );
      });

      loader.load( 'models/circle-core.glb', function ( gltf ) {
        blocksCore = gltf.scene.clone();
        scene.add(blocksCore);
        blocksCore.position.y = 10;
        blocksCore.traverse ( ( o ) => { o.material = materialCore; } );

      }, undefined, function ( error ) {
        console.error( error );
      });

      //Splat
      var splatArray = [];
      var currentSplat = 0;
    
      loader.load( 'models/splat.glb', function ( gltf ) {
        var splatMesh = gltf.scene.clone();
        splatMesh.traverse ( ( o ) => { o.material = splatMaterial; } );

        //Preinitialize spalts
        for(var i=0; i<10; i++)
        {
          splatArray[i] = gltf.scene.clone();
          splatArray[i].traverse ( ( o ) => { o.material = splatMaterial; } );
          scene.add(splatArray[i]);
          splatArray[i].position.set(0,10,0.5);
        }

      }, undefined, function ( error ) {

        console.error( error );
      } );

    //SOUND AND MUSIC
    var soundAdPlayed;
    var musicMute = false;
    var soundMute = false;
    var audioLoader = new THREE.AudioLoader();
    var listener = new THREE.AudioListener();
    camera.add(listener);

    //Load music
    audioLoader = new THREE.AudioLoader();
    var music = new THREE.Audio( listener );
    audioLoader.load( 'sounds/music.mp3', function( buffer ) {
      music.setBuffer( buffer );
      music.setLoop( true );
      music.setVolume( 0.5 );
      music.play();
      CheckMusicSoundMute();
    });

    //Sound
    var audioSources = [];

    LoadSound('bounce');
    LoadSound('mistake');
    LoadSound('broken');
    LoadSound('level-start');
    LoadSound('level-complete');
    LoadSound('brake-ring');

    function LoadSound(soundName)
    {
      audioLoader.load( 'sounds/' + soundName + '.mp3', function ( buffer )
      {
        audioSources[soundName] = new THREE.PositionalAudio( listener );
        audioSources[soundName].setBuffer( buffer );
        camera.add(audioSources[soundName]);
      } );
    }

    function PlaySound(soundName)
    {
      if(!soundMute && !adIsShowing)
        audioSources[soundName].play();
    }

    //Music tsound toggle
    function ToggleMusic()
    {
      musicMute = !musicMute;
      localStorage.setItem(localStoragePrefix+"musicMute", musicMute);
      CheckMusicSoundMute();
    }

    function ToggleSound()
    {
      soundMute = !soundMute;
      localStorage.setItem(localStoragePrefix+"soundMute", soundMute);
      CheckMusicSoundMute();
    }

    function CheckMusicSoundMute()
    {
      //Music
      if(musicMute == true)
      {
        $('#buttonMusic').addClass('toggleButtonOff');
        music.setVolume(0);
      }
      else
      {
        $('#buttonMusic').removeClass('toggleButtonOff');
        music.setVolume(0.5);
      }
      //Sound
      if(soundMute == true)
      {
        $('#buttonSound').addClass('toggleButtonOff');
      }
      else
      {
        $('#buttonSound').removeClass('toggleButtonOff');
      }
    }

    /// Generation
    function RandomizeWorldColors()
    {
      worldColorIn = Math.floor(Math.random() * worldColors.length);
      console.log("color in: " + worldColorIn);

      //renderer.setClearColor (worldColors[worldColorIn][3], 1);
      materialBall = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][1] } );
      materialCore = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0], transparent: true, opacity: 0.5, side: THREE.DoubleSide } );
      materialOk = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0] } );
      materialSpecial = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0], transparent: true, opacity: 0.7, side: THREE.DoubleSide } );
      materialKo = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][1] } );
      materialFinish = new THREE.MeshPhongMaterial( { color: worldColors[worldColorIn][0] } );
      splatMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'img/splat-1.png' ), transparent: true, opacity: 1, color: worldColors[worldColorIn][1] });

      ball.material = materialBall;
      blocksCore.traverse ( ( o ) => { o.material = materialCore; } );

      var spriteMaterial = new THREE.SpriteMaterial( 
      { 
        map: new THREE.ImageUtils.loadTexture( 'img/circle-gradient.png' ), 
        useScreenCoordinates: false,
        color: worldColors[worldColorIn][1], transparent: true, blending: THREE.AdditiveBlending
      });
      ballGlow.material = spriteMaterial;

      //Load background texture
      var bgTexture;
      var loader = new THREE.TextureLoader();
      loader.load('img/splat-1.png' , function(texture)
      {
        /*bgTexture = texture;
        scene.background = bgTexture;
        //scene.background.setSize(20,20);
        bgTexture.setSize(20,20);
        bgTexture.wrapS = THREE.MirroredRepeatWrapping;
        bgTexture.wrapT = THREE.MirroredRepeatWrapping;*/
      });
      

      
    }

    //Game Generation
    function GenerateLevelSettings()
    {
      //Platform count till finish
      piecesOnLevel = 8 + (currentLevel*2);

      //Cahnce for get a red kill zone
      chanceForDeadPiece = 10 + (currentLevel*2);
      if(chanceForDeadPiece > 50)
        chanceForDeadPiece = 50;

      console.log("ckz:" + chanceForDeadPiece);


      blocksCore.position.y = -piecesOnLevel;
      blocksCore.scale.y = piecesOnLevel + 0.2;
    }

    function RespawnPlatform()
    {
      nextPosYForRespawn-=1;
      
      UpdateGameUI();

      PlaySound("broken");

      //Respawn under num slots!
      if(numPlatformsSpawned <= piecesOnLevel)
        GeneratePlatform();

    }

	//Particles
	var particles = [];
	var particlesCount = 20;
	var currentParticle = 0;
	var particlesInitialized = false;
	
	function InitParticles()
	{
		if(particlesInitialized == true)
			return;
		
		for(var i=0; i<= particlesCount; i++)
		{
			particles[i] = new THREE.Mesh( new THREE.BoxGeometry( 0.05,0.05,0.05 ), materialOk );
			scene.add(particles[i]);
			particles[i].position.set(0,1,0);
		}
		particlesInitialized = true;
	}
	
	function SpawnParticle(particleColor)
	{
		if(particles[currentParticle] != null)
		{
			var rndAngle = Math.floor(Math.random() * 360);
        
	        var vectorBallPos = new THREE.Vector3();
	        var ballPos = vectorBallPos.setFromMatrixPosition( ball.matrixWorld );
	        
	        particles[currentParticle].position.copy(ballPos);
	        particles[currentParticle].rotation.y += (rndAngle * Math.PI)/180;
	        
	        if(particleColor == 0)
	        {
		        particles[currentParticle].material = materialBall;
	        }
	        else
	        {
		        particles[currentParticle].material = materialOk;
	        }
	        
	        
	        particles[currentParticle].scale.set(1,1,1);
	        
	        currentParticle++;
	        if(currentParticle >= particlesCount)
	        		currentParticle = 0;
		}
		
	}
	
	function UpdateParticles()
	{
		for(var i=0; i<= particlesCount; i++)
		{
			if(particles[i] != null)
			{
				particles[i].translateZ(-0.01);
				
				var scale = particles[i].scale.x;
				if(scale > 0)
				{
					scale -= 0.05;
					particles[i].scale.set(scale,scale,scale);
				}
				
			}
		}
	}

	//fuNCTIONS
    function AddScore(scoreValue)
    {
      score+=scoreValue;
      ShowScoreHUB(scoreValue);
    }
  

    var arrayWalls = [];    
    function GenerateWall()
    {

    }

    function GeneratePlatform()
    {
      var numEmptySlots = 0;

      var chanceForSpawn = 20+(currentLevel*5);
      if(chanceForSpawn > 80)
        chanceForSpawn = 80;

      console.log("cfs: " + chanceForSpawn);

      var wallSpawned = false;

      for(var i=0; i<16; i++)
      {
          var rndChance = Math.floor((Math.random() * 100) + 1);
          //var chanceForSpecial = Math.floor((Math.random() * 100) + 1);

          var forceEmptySlot = false;

          if(i==15 && numEmptySlots == 0)
          {
            forceEmptySlot = true;
          }

          //Finish piece all fill
          if(numPlatformsSpawned >= piecesOnLevel)
          {
            forceEmptySlot = false;
            rndChance = 0;
          }

          //First one without hole on start point
          if(numPlatformsSpawned == 0 && i==8)
          {
            console.log("first one!");
            console.log(i);
            forceEmptySlot = false;
            rndChance = 0;
            //chanceForSpecial = 100;
          }

          if(rndChance < chanceForSpawn && forceEmptySlot == false)
          {
            var platform = new THREE.Mesh( new THREE.BoxGeometry( 0.001,0.001,0.001 ), materialOk );
            pivot.add(platform);
            platform.position.set(0,lastPosY,0);

            var angleY = (22.5 * Math.PI)/180;
            platform.rotation.y = i * angleY;
            platform.translateZ(-0.805);

            var model = blockMesh.clone();

            platform.add(model);
            model.position.set(0,0,0.06);
            model.rotation.y = 0;

            platform.userData = { platformType: "normal", isSplated: false, killingSpeed: Math.floor(Math.random() * 25)*0.01 };

            //Wall?
            //GenerateWall();
            var chanceForSpawnWall = Math.floor((Math.random() * 100) + 1);
            var chanfeForWallTarget = (5+(currentLevel*5));
            if(chanfeForWallTarget > 80)
              chanfeForWallTarget = 80;

            if(numPlatformsSpawned == 0)
              chanceForSpawnWall = 100;

            if(numPlatformsSpawned < piecesOnLevel && wallSpawned == false && chanceForSpawnWall < chanfeForWallTarget)
            {
              var isMovable = true;
              var chanceForRotationWall = Math.floor((Math.random() * 100) + 1);
              if(chanceForRotationWall < 50 || currentLevel <= 3)
                isMovable = false;

              var wallPivot = new THREE.Mesh( new THREE.BoxGeometry( 0.001,0.001,0.001 ), materialOk );
              
              wallPivot.userData = { wallType: "normal", rotationSpeed: (0.5 + Math.floor(Math.random() * 100)*0.01) };

              //negative rot speed
              if(chanceForRotationWall > 75 && currentLevel > 3)
                wallPivot.userData.rotationSpeed = -wallPivot.userData.rotationSpeed;

              wallPivot.position.set(0,lastPosY,0);

              var wall = wallMesh.clone();
              wallPivot.add(wall);

              wall.position.set(0,0.35,0);

              if(isMovable)
              {
                pivot.add(wallPivot);
                wall.translateZ(-0.805);
                wallPivot.userData.wallType = "rotate";
              }
              else
              {
                platform.add(wallPivot);
                wallPivot.position.set(0,0,0);
              }
              
              var rndPosition = Math.floor((Math.random() * 100) + 1);
              if(rndPosition<50)
              {
                wall.translateX(0.14);
                wall.rotation.y += (-11.25 * Math.PI)/180;
              }
              else
              {
                wall.translateX(-0.14);
                wall.rotation.y += (11.25 * Math.PI)/180;
              }
              
              arrayWalls.push(wallPivot);

              wall.traverse ( ( o ) => {
                if ( o.isMesh ) {
                  o.material = materialKo;
                  o.castShadow = true;
                  o.receiveShadow = true;
                }
              });

              wallSpawned = true;
            }

            //ASsign materials and type
            model.traverse ( ( o ) => {
              if ( o.isMesh ) {
                o.material = materialOk;
                o.castShadow = true;
                o.receiveShadow = true;
              }
            } );

            if(numPlatformsSpawned >= piecesOnLevel)
            {
              model.traverse ( ( o ) => {
                if ( o.isMesh ) {
                  o.material = materialFinish;
                  platform.userData.platformType = "finish";

                  lastBlockPositionY = lastPosY;
                }
              } );
            }
            else
            {
              model.traverse ( ( o ) => {
                if ( o.isMesh ) {
                  if(rndChance < chanceForDeadPiece && numPlatformsSpawned >= 1)
                  {
                    o.material = materialKo;
                    platform.userData.platformType = "dead";
                    //model.scale.set(1,0.9,1.1);
                    //model.translateZ(-0.025);
                  }
                }
              });
            }

          }
          else
          {
            //Empty slot!
            numEmptySlots++;
          }
        }

        lastPosY -= 1;

        numPlatformsSpawned++;
      }

      function GenerateSplat(platformParent)
      {
        currentSplat++;
        if(currentSplat >= 10)
          currentSplat = 0;

        splatArray[currentSplat].traverse ( ( o ) => { o.material = splatMaterial; } );
        platformParent.add(splatArray[currentSplat]);
        splatArray[currentSplat].position.set(0,0.11,0.5);
        //model.rotation.y = Math.floor(Math.random() * 360);
      }
      
      //Camera
      var shakeFactor = 0;
      var shakeFactorTarget = 0.02;
      function ShakeCamera()
      {
	      camera.position.x += -shakeFactor + (Math.random() * (shakeFactor*2));
	      camera.position.y += -shakeFactor + (Math.random() * (shakeFactor*2));
	      
	      if(shakeFactor > 0)
	      {
		      shakeFactor -= 0.00025;
	      } 
	      else if(shakeFactor < 0)
	      {
		      shakeFactor = 0;
	      }
	      	
      }
      
      //UPDATE

      var delta = 0;

      var animate = function ()
      {
        requestAnimationFrame( animate );

        delta = clock.getDelta();

        scene.updateMatrixWorld();

        //Dont run when not in tab
        if(isPaused == true)
        {
          return false;
        }

        //console.log(ballGravity);

        //Gravity!
        if(gameState == 0 || gameState == 1)
        {
          //Keyboard 
          if(keyboard.pressed("A") || keyboard.pressed("left"))
          {
            pivot.rotation.y += delta * 3.5;
          }
          else if(keyboard.pressed("D") || keyboard.pressed("right"))
          {
            pivot.rotation.y -= delta * 3.5;
          }

          //Gravity
          ballGravity += 0.3;

          //Clamp speed limit
          var speedLimit = 5;
          if(ballGravity > speedLimit)
            ballGravity = speedLimit;

          if(ballGravity<-speedLimit)
            ballGravity=-speedLimit;

          //apply gravity
          ball.position.y -= ballGravity*delta;

          //Ball scale
          if(ball.scale.x > 0.8)
          {
            ball.scale.x -= 0.05;
            ball.scale.z = ball.scale.x;
          }
          
          if(ball.scale.y < ball.scale.x)
            ball.scale.y += 0.05;


          //Scale effect according to no bounce factor
          var scaleFactor = platformsWithoutBounceCount*0.05;
          ball.scale.x = ball.scale.x+scaleFactor;
          ball.scale.y = ball.scale.y+scaleFactor;
          ball.scale.z = ball.scale.z+scaleFactor;

          //Clamp scale
          var maxScale = 1.25;
          if(ball.scale.x > maxScale)
            ball.scale.x = maxScale;

          if(ball.scale.y > maxScale)
            ball.scale.y = maxScale;

          if(ball.scale.z > maxScale)
            ball.scale.z = maxScale;
            
        }
        else if(gameState == 3)
        {
          ball.scale.set(0.01,0.01,0.01);
        }

        //Get current platform and "collide"
        var closestDist = 1000;
        var closestPlatform;
        var closestPlatformPos;

        var vectorBallPos = new THREE.Vector3();
        var ballPos = vectorBallPos.setFromMatrixPosition( ball.matrixWorld );

        for(var i=0; i<pivot.children.length; i++)
        {
           var vectorPlatform = new THREE.Vector3();
           var platformPos = vectorPlatform.setFromMatrixPosition( pivot.children[i].matrixWorld );

           if(platformPos.y <= ballPos.y)
           {
            var distTo = ballPos.distanceTo(platformPos);
            if(distTo<closestDist)
            {
              closestPlatform = pivot.children[i];
              closestDist = distTo;

              closestPlatformPos = platformPos;
            }
          }
        }

          //Collide with walls
          if( gameState == 1 && arrayWalls.length > 0)
          {
            //console.log(arrayWalls.length);
            for(var i=0; i<arrayWalls.length; i++)
            {
              if(arrayWalls[i] != null)
              {
                if(arrayWalls[i].userData.wallType == "rotate")
                {
                  arrayWalls[i].rotation.y += delta*arrayWalls[i].userData.rotationSpeed;
                }
                
                var vectorWall = new THREE.Vector3();
                var wallPos = vectorWall.setFromMatrixPosition( arrayWalls[i].children[0].matrixWorld );
                var distTo = ballPos.distanceTo(wallPos);
                if(distTo<0.1)
                {
                  if(platformsWithoutBounceCount >= 3)
                  {
                    RespawnPlatform();
                    AddScore(2);
                    PlaySound("brake-ring");
                    
                    shakeFactor = shakeFactorTarget;

                    platformsWithoutBounceCount = 0;//Restore no bounce count...

                    ballGravity = -4.75;//jump up!
                    ball.scale.set(1.5,0.4,1.5);
                    
                    for(var i=0; i<10; i++)
                      SpawnParticle(1);
                  }
                  else
                  {
                    lastWallBounced = arrayWalls[i];
                    PlaySound("mistake");
                    GameOver();
                    
                    try {
					parent.post_ad();
					console.log("ad");
				} catch (error) {
					console.error("ad",error);
				}
                  }
                }
              }
            }
          }

          //Bounce
          if(closestPlatform != null && ballGravity > 0 && gameState != 2)
          {
            //var distOnX = Math.abs(closestPlatformPos.x);
            //closestPlatform.scale.y = 0.8;
            if(closestDist < 0.22 && ballPos.y <= nextPosYForRespawn+0.75)
            //if(closestDist < 0.26 && ballPos.y < (closestPlatformPos.y+0.25))
            {
              //console.log(ballPos.y + " / " + nextPosYForRespawn);
              //console.log(ballPos.x + " / " + closestPlatformPos.x);

              var platformType = closestPlatform.userData.platformType;

              
              if(platformType == "normal")
              {
                if(!soundMute)
                  PlaySound('bounce');

                if(platformsWithoutBounceCount >= 3)
                {
                  RespawnPlatform();
                  AddScore(2);
                  PlaySound("brake-ring");
                  
                  shakeFactor = shakeFactorTarget;
                  
                  for(var i=0; i<10; i++)
	                  SpawnParticle(1);
                }

              }
              else if(platformType == "special")
              {
                RespawnPlatform();
                AddScore(2);

                if(!soundMute)
                  PlaySound('bounce');
              }
              else if(platformType == "finish")
              {
                CompleteLevel();
              }
              else//KILL ZONE
              {
                if(platformsWithoutBounceCount >= 3)
                {
                  RespawnPlatform();
                  AddScore(2);
                  PlaySound("brake-ring");
                  
                  shakeFactor = shakeFactorTarget;
                  
                  for(var i=0; i<10; i++)
	                  SpawnParticle(1);
                }
                else
                {
                  lastBlockBounced = closestPlatform;
                  //But.. die!
                  GameOver();
                  PlaySound("mistake");
                  
                  try {
					var parent_window = window.parent;
					parent_window.postMessage("show_middle_ad|", "*");
					console.log("gameover");
				} catch (error) {
					console.error("show_middle_ad",error);
				}
                }   
              }

              platformsWithoutBounceCount = 0;//Restore no bounce count...

              ballGravity = -4.75;//jump up!
              //ball.scale.y = 0.4;
              ball.scale.set(1.5,0.4,1.5);

              if(closestPlatform.userData.isSplated == false)
              {
                GenerateSplat(closestPlatform);
                closestPlatform.userData.isSplated = true;
              }
              
            }
          }
        //}//End if gamestate == 1

        //Core
        /*if(blocksCore != null)
          blocksCore.position.y = ball.position.y + 0.5;*/

        //Respawn!
        if( ballPos.y < nextPosYForRespawn && gameState == 1)
        {
          RespawnPlatform();
          platformsWithoutBounceCount++;
          AddScore(platformsWithoutBounceCount);
          console.log("No bounce: " + platformsWithoutBounceCount);
        }

        for(var i=0; i<pivot.children.length; i++)
        {
          var vector1 = new THREE.Vector3();
          var p2 = vector1.setFromMatrixPosition( pivot.children[i].matrixWorld );

          if(p2.y - 0.5 > nextPosYForRespawn && p2.y < 0)
          {
            pivot.children[i].translateZ(-pivot.children[i].userData.killingSpeed);
            pivot.children[i].rotation.z += 0.1;

            if(pivot.children[i].scale.x > 0)
            {
              pivot.children[i].scale.x-=0.05;
              pivot.children[i].scale.y-=0.05;
              pivot.children[i].scale.z-=0.05;
            }
            else
            {
              pivot.remove(pivot.children[i]);
              //break;
            }
          }
        }
        //console.log("finish√ß: " + lastBlockPositionY);
        //Complete level (infinite bug fall fix)
        if(ballPos.y <= lastBlockPositionY+0.5)
        {
          CompleteLevel();
        }

        //Camera position
        if(cameraTargetY > ballPos.y)
            cameraTargetY = ballPos.y;

        camera.position.y = lerp(camera.position.y, cameraTargetY + 1, delta * 8);//posBall.y + 0.25;
        camera.position.x = lerp(camera.position.x, 0, delta * 8);
        
        ShakeCamera();
        
        //
        camera.position.z = 2.5;

        //Shadow light position
        shadowLight.position.set( 0, ball.position.y+3, 3);
        
        //Ball glow
        if(platformsWithoutBounceCount < 3)
        {
          ballGlow.scale.set(0.01,0.01,0.01);
        }
        else
        {
          //var valScale = ballGlow.scale.x;
          //var newVarScale = lerp(valScale, 1, delta * 8);
          ballGlow.scale.set(1,1,1);
        } 

        //Particles
  		  if(gameState == 1 && ballGravity > 2)
  		  {
  			 SpawnParticle(0);
  		  }
        
        UpdateParticles();
        

        renderer.render( scene, camera );
      };

      animate();

      window.addEventListener( 'touchstart', onTouchStart, false );
      window.addEventListener( 'touchmove', onTouchMove, {passive:false} );
      window.addEventListener( 'touchend', onTouchEnd, false );

      window.addEventListener( 'mousedown', onMouseDown, false );
      window.addEventListener( 'mouseup', onMouseUp, false );
      window.addEventListener( 'mousemove', onMouseMove, false );

      var mouse = new THREE.Vector2();
      var mouseDown = false;
      var lastMouseX = 0;

      //Tap
      function onTouchMove(event)
      {
        mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;

        var dist = lastMouseX - mouse.x;

        //Apply rotation
        if(canPlay && mouseDown)
        {
          pivot.rotation.y -= (dist * 120) * delta;
        }

        lastMouseX = mouse.x;

        //alert(event.touches[0].clientX);

        event.preventDefault();
      }
      function onTouchStart(event)
      {

        mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;
        lastMouseX = mouse.x;

        mouseDown = true;
      }
      function onTouchEnd(event)
      {
        mouseDown = false;
      }


      //Mouse
      function onMouseMove( event ) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        var dist = lastMouseX - mouse.x;

        //Apply rotation
        if(canPlay && mouseDown)
        {
          pivot.rotation.y -= (dist * 160) * delta;
        }

        lastMouseX = mouse.x;
        //event.preventDefault();
    }

    function onMouseDown()
    {
      mouseDown = true;
    }
    function onMouseUp()
    {
      mouseDown = false;
    }

    //Keyboard
    $(window).keypress(function(e) {
      if (e.which === 32) 
      {
        //Restart game on game over (space bar)
        if(gameState == 2)
        {
          RestartGame();
        }
      }
    });

  
    //HELPERS
    function lerp (start, end, amt){
      return (1-amt)*start+amt*end
    }

    //ADS
    var rewardedVideoWasShowed = false;
    var adIsShowing = false;

    

  

    

    
 
 

    var rewardedVideoWasShowed = false;

     
//PAUSE
  var isPaused = false;
  function EnablePause()
  {
    isPaused = true;
    console.log("EnablePause");

    music.pause();
  }
  function DisablePause()
  {
    isPaused = false;
    console.log("DisablePause");

    music.play();
  }


  /////////////////////////////////////////
  // main visibility API function 
  // check if current tab is active or not
  var vis = (function(){
      var stateKey, 
          eventKey, 
          keys = {
                  hidden: "visibilitychange",
                  webkitHidden: "webkitvisibilitychange",
                  mozHidden: "mozvisibilitychange",
                  msHidden: "msvisibilitychange"
      };
      for (stateKey in keys) {
          if (stateKey in document) {
              eventKey = keys[stateKey];
              break;
          }
      }
      return function(c) {
          if (c) document.addEventListener(eventKey, c);
          return !document[stateKey];
      }
  })();


  /////////////////////////////////////////
  // check if current tab is active or not
  vis(function(){
            
      if(vis()){  
          
          // the setTimeout() is used due to a delay 
          // before the tab gains focus again, very important!
          setTimeout(function(){ 
            DisablePause();
          },300);   
                          
      } else {
        EnablePause();
      }
  });


  /////////////////////////////////////////
  // check if browser window has focus    
  var notIE = (document.documentMode === undefined),
      isChromium = window.chrome;
        
  if (notIE && !isChromium) {

      // checks for Firefox and other  NON IE Chrome versions
      $(window).on("focusin", function () { 
          
          setTimeout(function(){      
              DisablePause();
          },300);

      }).on("focusout", function () {
        EnablePause();
      });

  } else {
      
      // checks for IE and Chromium versions
      if (window.addEventListener) {

          // bind focus event
          window.addEventListener("focus", function (event) {
            
              setTimeout(function(){                 
                   DisablePause();
              },300);

          }, false);

          // bind blur event
          window.addEventListener("blur", function (event) {
            EnablePause();
          }, false);

      } else {

          // bind focus event
          window.attachEvent("focus", function (event) {

              setTimeout(function(){                 
                DisablePause();
              },300);

          });

          // bind focus event
          window.attachEvent("blur", function (event) {
            EnablePause();
          });
      }
  }

    </script>

<script>
    function setLoadingVisible(visible, isEnd, loadCall) {
        if (window.parent != window) {
            window.parent.setLoadingVisible(visible, isEnd, loadCall);       
        }
    }
    function setBannerVisible(index, visible) {
        if (window.parent != window) {
            window.parent.setBannerVisible(index, visible);        
        }
    };
</script>
  </body>
  </html>